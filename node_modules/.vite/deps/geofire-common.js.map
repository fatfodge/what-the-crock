{
  "version": 3,
  "sources": ["../../geofire-common/dist/geofire-common/index.esm.js"],
  "sourcesContent": ["// Default geohash length\r\nvar GEOHASH_PRECISION = 10;\r\n// Characters used in location geohashes\r\nvar BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';\r\n// The meridional circumference of the earth in meters\r\nvar EARTH_MERI_CIRCUMFERENCE = 40007860;\r\n// Length of a degree latitude at the equator\r\nvar METERS_PER_DEGREE_LATITUDE = 110574;\r\n// Number of bits per geohash character\r\nvar BITS_PER_CHAR = 5;\r\n// Maximum length of a geohash in bits\r\nvar MAXIMUM_BITS_PRECISION = 22 * BITS_PER_CHAR;\r\n// Equatorial radius of the earth in meters\r\nvar EARTH_EQ_RADIUS = 6378137.0;\r\n// The following value assumes a polar radius of\r\n// const EARTH_POL_RADIUS = 6356752.3;\r\n// The formulate to calculate E2 is\r\n// E2 == (EARTH_EQ_RADIUS^2-EARTH_POL_RADIUS^2)/(EARTH_EQ_RADIUS^2)\r\n// The exact value is used here to avoid rounding errors\r\nvar E2 = 0.00669447819799;\r\n// Cutoff for rounding errors on double calculations\r\nvar EPSILON = 1e-12;\r\nfunction log2(x) {\r\n    return Math.log(x) / Math.log(2);\r\n}\r\n/**\r\n * Validates the inputted key and throws an error if it is invalid.\r\n *\r\n * @param key The key to be verified.\r\n */\r\nfunction validateKey(key) {\r\n    var error;\r\n    if (typeof key !== 'string') {\r\n        error = 'key must be a string';\r\n    }\r\n    else if (key.length === 0) {\r\n        error = 'key cannot be the empty string';\r\n    }\r\n    else if (1 + GEOHASH_PRECISION + key.length > 755) {\r\n        // Firebase can only stored child paths up to 768 characters\r\n        // The child path for this key is at the least: 'i/<geohash>key'\r\n        error = 'key is too long to be stored in Firebase';\r\n    }\r\n    else if (/[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/.test(key)) {\r\n        // Firebase does not allow node keys to contain the following characters\r\n        error = 'key cannot contain any of the following characters: . # $ ] [ /';\r\n    }\r\n    if (typeof error !== 'undefined') {\r\n        throw new Error('Invalid GeoFire key \\'' + key + '\\': ' + error);\r\n    }\r\n}\r\n/**\r\n * Validates the inputted location and throws an error if it is invalid.\r\n *\r\n * @param location The [latitude, longitude] pair to be verified.\r\n */\r\nfunction validateLocation(location) {\r\n    var error;\r\n    if (!Array.isArray(location)) {\r\n        error = 'location must be an array';\r\n    }\r\n    else if (location.length !== 2) {\r\n        error = 'expected array of length 2, got length ' + location.length;\r\n    }\r\n    else {\r\n        var latitude = location[0];\r\n        var longitude = location[1];\r\n        if (typeof latitude !== 'number' || isNaN(latitude)) {\r\n            error = 'latitude must be a number';\r\n        }\r\n        else if (latitude < -90 || latitude > 90) {\r\n            error = 'latitude must be within the range [-90, 90]';\r\n        }\r\n        else if (typeof longitude !== 'number' || isNaN(longitude)) {\r\n            error = 'longitude must be a number';\r\n        }\r\n        else if (longitude < -180 || longitude > 180) {\r\n            error = 'longitude must be within the range [-180, 180]';\r\n        }\r\n    }\r\n    if (typeof error !== 'undefined') {\r\n        throw new Error('Invalid GeoFire location \\'' + location + '\\': ' + error);\r\n    }\r\n}\r\n/**\r\n * Validates the inputted geohash and throws an error if it is invalid.\r\n *\r\n * @param geohash The geohash to be validated.\r\n */\r\nfunction validateGeohash(geohash) {\r\n    var error;\r\n    if (typeof geohash !== 'string') {\r\n        error = 'geohash must be a string';\r\n    }\r\n    else if (geohash.length === 0) {\r\n        error = 'geohash cannot be the empty string';\r\n    }\r\n    else {\r\n        for (var _i = 0, geohash_1 = geohash; _i < geohash_1.length; _i++) {\r\n            var letter = geohash_1[_i];\r\n            if (BASE32.indexOf(letter) === -1) {\r\n                error = 'geohash cannot contain \\'' + letter + '\\'';\r\n            }\r\n        }\r\n    }\r\n    if (typeof error !== 'undefined') {\r\n        throw new Error('Invalid GeoFire geohash \\'' + geohash + '\\': ' + error);\r\n    }\r\n}\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param degrees The number of degrees to be converted to radians.\r\n * @returns The number of radians equal to the inputted number of degrees.\r\n */\r\nfunction degreesToRadians(degrees) {\r\n    if (typeof degrees !== 'number' || isNaN(degrees)) {\r\n        throw new Error('Error: degrees must be a number');\r\n    }\r\n    return (degrees * Math.PI / 180);\r\n}\r\n/**\r\n * Generates a geohash of the specified precision/string length from the  [latitude, longitude]\r\n * pair, specified as an array.\r\n *\r\n * @param location The [latitude, longitude] pair to encode into a geohash.\r\n * @param precision The length of the geohash to create. If no precision is specified, the\r\n * global default is used.\r\n * @returns The geohash of the inputted location.\r\n */\r\nfunction geohashForLocation(location, precision) {\r\n    if (precision === void 0) { precision = GEOHASH_PRECISION; }\r\n    validateLocation(location);\r\n    if (typeof precision !== 'undefined') {\r\n        if (typeof precision !== 'number' || isNaN(precision)) {\r\n            throw new Error('precision must be a number');\r\n        }\r\n        else if (precision <= 0) {\r\n            throw new Error('precision must be greater than 0');\r\n        }\r\n        else if (precision > 22) {\r\n            throw new Error('precision cannot be greater than 22');\r\n        }\r\n        else if (Math.round(precision) !== precision) {\r\n            throw new Error('precision must be an integer');\r\n        }\r\n    }\r\n    var latitudeRange = {\r\n        min: -90,\r\n        max: 90\r\n    };\r\n    var longitudeRange = {\r\n        min: -180,\r\n        max: 180\r\n    };\r\n    var hash = '';\r\n    var hashVal = 0;\r\n    var bits = 0;\r\n    var even = 1;\r\n    while (hash.length < precision) {\r\n        var val = even ? location[1] : location[0];\r\n        var range = even ? longitudeRange : latitudeRange;\r\n        var mid = (range.min + range.max) / 2;\r\n        if (val > mid) {\r\n            hashVal = (hashVal << 1) + 1;\r\n            range.min = mid;\r\n        }\r\n        else {\r\n            hashVal = (hashVal << 1) + 0;\r\n            range.max = mid;\r\n        }\r\n        even = !even;\r\n        if (bits < 4) {\r\n            bits++;\r\n        }\r\n        else {\r\n            bits = 0;\r\n            hash += BASE32[hashVal];\r\n            hashVal = 0;\r\n        }\r\n    }\r\n    return hash;\r\n}\r\n/**\r\n * Calculates the number of degrees a given distance is at a given latitude.\r\n *\r\n * @param distance The distance to convert.\r\n * @param latitude The latitude at which to calculate.\r\n * @returns The number of degrees the distance corresponds to.\r\n */\r\nfunction metersToLongitudeDegrees(distance, latitude) {\r\n    var radians = degreesToRadians(latitude);\r\n    var num = Math.cos(radians) * EARTH_EQ_RADIUS * Math.PI / 180;\r\n    var denom = 1 / Math.sqrt(1 - E2 * Math.sin(radians) * Math.sin(radians));\r\n    var deltaDeg = num * denom;\r\n    if (deltaDeg < EPSILON) {\r\n        return distance > 0 ? 360 : 0;\r\n    }\r\n    else {\r\n        return Math.min(360, distance / deltaDeg);\r\n    }\r\n}\r\n/**\r\n * Calculates the bits necessary to reach a given resolution, in meters, for the longitude at a\r\n * given latitude.\r\n *\r\n * @param resolution The desired resolution.\r\n * @param latitude The latitude used in the conversion.\r\n * @return The bits necessary to reach a given resolution, in meters.\r\n */\r\nfunction longitudeBitsForResolution(resolution, latitude) {\r\n    var degs = metersToLongitudeDegrees(resolution, latitude);\r\n    return (Math.abs(degs) > 0.000001) ? Math.max(1, log2(360 / degs)) : 1;\r\n}\r\n/**\r\n * Calculates the bits necessary to reach a given resolution, in meters, for the latitude.\r\n *\r\n * @param resolution The bits necessary to reach a given resolution, in meters.\r\n * @returns Bits necessary to reach a given resolution, in meters, for the latitude.\r\n */\r\nfunction latitudeBitsForResolution(resolution) {\r\n    return Math.min(log2(EARTH_MERI_CIRCUMFERENCE / 2 / resolution), MAXIMUM_BITS_PRECISION);\r\n}\r\n/**\r\n * Wraps the longitude to [-180,180].\r\n *\r\n * @param longitude The longitude to wrap.\r\n * @returns longitude The resulting longitude.\r\n */\r\nfunction wrapLongitude(longitude) {\r\n    if (longitude <= 180 && longitude >= -180) {\r\n        return longitude;\r\n    }\r\n    var adjusted = longitude + 180;\r\n    if (adjusted > 0) {\r\n        return (adjusted % 360) - 180;\r\n    }\r\n    else {\r\n        return 180 - (-adjusted % 360);\r\n    }\r\n}\r\n/**\r\n * Calculates the maximum number of bits of a geohash to get a bounding box that is larger than a\r\n * given size at the given coordinate.\r\n *\r\n * @param coordinate The coordinate as a [latitude, longitude] pair.\r\n * @param size The size of the bounding box.\r\n * @returns The number of bits necessary for the geohash.\r\n */\r\nfunction boundingBoxBits(coordinate, size) {\r\n    var latDeltaDegrees = size / METERS_PER_DEGREE_LATITUDE;\r\n    var latitudeNorth = Math.min(90, coordinate[0] + latDeltaDegrees);\r\n    var latitudeSouth = Math.max(-90, coordinate[0] - latDeltaDegrees);\r\n    var bitsLat = Math.floor(latitudeBitsForResolution(size)) * 2;\r\n    var bitsLongNorth = Math.floor(longitudeBitsForResolution(size, latitudeNorth)) * 2 - 1;\r\n    var bitsLongSouth = Math.floor(longitudeBitsForResolution(size, latitudeSouth)) * 2 - 1;\r\n    return Math.min(bitsLat, bitsLongNorth, bitsLongSouth, MAXIMUM_BITS_PRECISION);\r\n}\r\n/**\r\n * Calculates eight points on the bounding box and the center of a given circle. At least one\r\n * geohash of these nine coordinates, truncated to a precision of at most radius, are guaranteed\r\n * to be prefixes of any geohash that lies within the circle.\r\n *\r\n * @param center The center given as [latitude, longitude].\r\n * @param radius The radius of the circle in meters.\r\n * @returns The center of the box, and the eight bounding box points.\r\n */\r\nfunction boundingBoxCoordinates(center, radius) {\r\n    var latDegrees = radius / METERS_PER_DEGREE_LATITUDE;\r\n    var latitudeNorth = Math.min(90, center[0] + latDegrees);\r\n    var latitudeSouth = Math.max(-90, center[0] - latDegrees);\r\n    var longDegsNorth = metersToLongitudeDegrees(radius, latitudeNorth);\r\n    var longDegsSouth = metersToLongitudeDegrees(radius, latitudeSouth);\r\n    var longDegs = Math.max(longDegsNorth, longDegsSouth);\r\n    return [\r\n        [center[0], center[1]],\r\n        [center[0], wrapLongitude(center[1] - longDegs)],\r\n        [center[0], wrapLongitude(center[1] + longDegs)],\r\n        [latitudeNorth, center[1]],\r\n        [latitudeNorth, wrapLongitude(center[1] - longDegs)],\r\n        [latitudeNorth, wrapLongitude(center[1] + longDegs)],\r\n        [latitudeSouth, center[1]],\r\n        [latitudeSouth, wrapLongitude(center[1] - longDegs)],\r\n        [latitudeSouth, wrapLongitude(center[1] + longDegs)]\r\n    ];\r\n}\r\n/**\r\n * Calculates the bounding box query for a geohash with x bits precision.\r\n *\r\n * @param geohash The geohash whose bounding box query to generate.\r\n * @param bits The number of bits of precision.\r\n * @returns A [start, end] pair of geohashes.\r\n */\r\nfunction geohashQuery(geohash, bits) {\r\n    validateGeohash(geohash);\r\n    var precision = Math.ceil(bits / BITS_PER_CHAR);\r\n    if (geohash.length < precision) {\r\n        return [geohash, geohash + '~'];\r\n    }\r\n    geohash = geohash.substring(0, precision);\r\n    var base = geohash.substring(0, geohash.length - 1);\r\n    var lastValue = BASE32.indexOf(geohash.charAt(geohash.length - 1));\r\n    var significantBits = bits - (base.length * BITS_PER_CHAR);\r\n    var unusedBits = (BITS_PER_CHAR - significantBits);\r\n    // delete unused bits\r\n    var startValue = (lastValue >> unusedBits) << unusedBits;\r\n    var endValue = startValue + (1 << unusedBits);\r\n    if (endValue > 31) {\r\n        return [base + BASE32[startValue], base + '~'];\r\n    }\r\n    else {\r\n        return [base + BASE32[startValue], base + BASE32[endValue]];\r\n    }\r\n}\r\n/**\r\n * Calculates a set of query bounds to fully contain a given circle, each being a [start, end] pair\r\n * where any geohash is guaranteed to be lexicographically larger than start and smaller than end.\r\n *\r\n * @param center The center given as [latitude, longitude] pair.\r\n * @param radius The radius of the circle.\r\n * @return An array of geohash query bounds, each containing a [start, end] pair.\r\n */\r\nfunction geohashQueryBounds(center, radius) {\r\n    validateLocation(center);\r\n    var queryBits = Math.max(1, boundingBoxBits(center, radius));\r\n    var geohashPrecision = Math.ceil(queryBits / BITS_PER_CHAR);\r\n    var coordinates = boundingBoxCoordinates(center, radius);\r\n    var queries = coordinates.map(function (coordinate) {\r\n        return geohashQuery(geohashForLocation(coordinate, geohashPrecision), queryBits);\r\n    });\r\n    // remove duplicates\r\n    return queries.filter(function (query, index) {\r\n        return !queries.some(function (other, otherIndex) {\r\n            return index > otherIndex && query[0] === other[0] && query[1] === other[1];\r\n        });\r\n    });\r\n}\r\n/**\r\n * Method which calculates the distance, in kilometers, between two locations,\r\n * via the Haversine formula. Note that this is approximate due to the fact that the\r\n * Earth's radius varies between 6356.752 km and 6378.137 km.\r\n *\r\n * @param location1 The [latitude, longitude] pair of the first location.\r\n * @param location2 The [latitude, longitude] pair of the second location.\r\n * @returns The distance, in kilometers, between the inputted locations.\r\n */\r\nfunction distanceBetween(location1, location2) {\r\n    validateLocation(location1);\r\n    validateLocation(location2);\r\n    var radius = 6371; // Earth's radius in kilometers\r\n    var latDelta = degreesToRadians(location2[0] - location1[0]);\r\n    var lonDelta = degreesToRadians(location2[1] - location1[1]);\r\n    var a = (Math.sin(latDelta / 2) * Math.sin(latDelta / 2)) +\r\n        (Math.cos(degreesToRadians(location1[0])) * Math.cos(degreesToRadians(location2[0])) *\r\n            Math.sin(lonDelta / 2) * Math.sin(lonDelta / 2));\r\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return radius * c;\r\n}\n\nexport { BASE32, BITS_PER_CHAR, E2, EARTH_EQ_RADIUS, EARTH_MERI_CIRCUMFERENCE, EPSILON, GEOHASH_PRECISION, MAXIMUM_BITS_PRECISION, METERS_PER_DEGREE_LATITUDE, boundingBoxBits, boundingBoxCoordinates, degreesToRadians, distanceBetween, geohashForLocation, geohashQuery, geohashQueryBounds, latitudeBitsForResolution, longitudeBitsForResolution, metersToLongitudeDegrees, validateGeohash, validateKey, validateLocation, wrapLongitude };\n"],
  "mappings": "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",
  "names": []
}
